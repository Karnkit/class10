// info about each config option.

var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG
  ? function () { console.error.apply(console, arguments) }
  : function () {}

var url = require("url")
  , path = require("path")
  , Stream = require("stream").Stream
  , abbrev = require("abbrev")

module.exports = exports = nopt
exports.clean = clean

exports.typeDefs =
  { String  : { type: String,  validate: validateString  }
  , Boolean : { type: Boolean, validate: validateBoolean }
  , url     : { type: url,     validate: validateUrl     }
  , Number  : { type: Number,  validate: validateNumber  }
  , path    : { type: path,    validate: validatePath    }
  , Stream  : { type: Stream,  validate: validateStream  }
  , Date    : { type: Date,    validate: validateDate    }
  }

function nopt (types, shorthands, args, slice) {
  args = args || process.argv
  types = types || {}
  shorthands = shorthands || {}
  if (typeof slice !== "number") slice = 2

  debug(types, shorthands, args, slice)

  args = args.slice(slice)
  var data = {}
    , key
    , remain = []
    , cooked = args
    , original = args.slice(0)

  parse(args, data, remain, types, shorthands)
  // now data is full
  clean(data, types, exports.typeDefs)
  data.argv = {remain:remain,cooked:cooked,original:original}
  data.argv.toString = function () {
    return this.original.map(JSON.stringify).join(" ")
  }
  return data
}

function clean (data, types, typeDefs) {
  typeDefs = typeDefs || exports.typeDefs
  var remove = {}
    , typeDefault = [false, true, null, String, Number]

  Object.keys(data).forEach(function (k) {
    if (k === "argv") return
    var val = data[k]
      , isArray = Array.isArray(val)
      , type = types[k]
    if (!isArray) val = [val]
    if (!type) type = typeDefault
    if (type === Array) type = typeDefault.concat(Array)
    if (!Array.isArray(type)) type = [type]

    debug("val=%j", val)
    debug("types=", type)
    val = val.map(function (val) {
      // if it's an unknown value, then parse false/true/null/numbers/dates
      if (typeof val === "string") {
        debug("string %j", val)
        val = val.trim()
        if ((val === "null" && ~type.indexOf(null))
            || (val === "true" &&
               (~type.indexOf(true) || ~type.indexOf(Boolean)))
            || (val === "false" &&
               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {
          val = JSON.parse(val)
          debug("jsonable %j", val)
        } else if (~type.indexOf(Number) && !isNaN(val)) {
          debug("convert to number", val)
          val = +val
        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
          debug("convert to date", val)
          val = new Date(val)
        }
      }

      if (!types.hasOwnProperty(k)) {
        return val
      }

      // allow `--no-blah` to set 'blah' to null if null is allowed
      if (val === false && ~type.indexOf(null) &&
          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
        val = null
      }

      var d = {}
      d[k] = val
      debug("prevalidated val", d, val, types[k])
      if (!validate(d, k, val, types[k], typeDefs)) {
        if (exports.invalidHandler) {
          exports.invalidHandler(k, val, types[k], data)
        } else if (exports.invalidHandler !== false) {
          debug("invalid: "+k+"="+val, types[k])
        }
        return remove
      }
      debug("validated val", d, val, types[k])
      return d[k]
    }).filter(function (val) { return val !== remove })

    if (!val.length) delete data[k]
    else if (isArray) {
      debug(isArray, data[k], val)
      data[k] = val
    } else data[k] = val[0]

    debug("k=%s val=%j", k, val, data[k])
  })
}

function validateString (data, k, val) {
  data[k] = String(val)
}

function validatePath (data, k, val) {
  data[k] = path.resolve(String(val))
  return true
}

function validateNumber (data, k, val) {
  debug("validate Number %j %j %j", k, val, isNaN(val))
  if (isNaN(val)) return false
  data[k] = +val
}

function validateDate (data, k, val) {
  debug("validate Date %j %j %j", k, val, Date.parse(val))
  var s = Date.parse(val)
  if (isNaN(s)) return false
  data[k] = new Date(val)
}

function validateBoolean (data, k, val) {
  if (val instanceof Boolean) val = val.valueOf()
  else if (typeof val === "string") {
    if (!isNaN(val)) val = !!(+val)
    else if (val === "null" || val === "false") val = false
    else val = true
  } else val = !!val
  data[k] = val
}

function validateUrl (data, k, val) {
  val = url.parse(String(val))
  if (!val.host) return false
  data[k] = val.href
}

function validateStream (data, k, val) {
  if (!(val instanceof Stream)) return false
  data[k] = val
}

function validate (data, k, val, type, typeDefs) {
  // arrays are lists of types.
  if (Array.isArray(type)) {
    for (var i = 0, l = type.length; i < l; i ++) {
      if (type[i] === Array) continue
      if (validate(data, k, val, type[i], typeDefs)) return true
    }
    delete data[k]
    return false
  }

  // an array of anything?
  if (type === Array) return true

  // NaN is poisonous.  Means that something is not allowed.
  if (type !== type) {
    debug("Poison NaN", k, val, type)
    delete data[k]
    return false
  }

  // explicit list of values
  if (val === type) {
    debug("Explicitly allowed %j", val)
    // if (isArray) (data[k] = data[k] || []).push(val)
    // else data[k] = val
    data[k] = val
    return true
  }

  // now go through the list of typeDefs, validate against each one.
  var ok = false
    , types = Object.keys(typeDefs)
  for (var i = 0, l = types.length; i < l; i ++) {
    debug("test type %j %j %j", k, val, types[i])
    var t = typeDefs[types[i]]
    if (t && type === t.type) {
      var d = {}
      ok = false !== t.validate(d, k, val)
      val = d[k]
      if (ok) {
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val
        break
      }
    }
  }
  debug("OK? %j (%j %j %j)", ok, k, val, types[i])

  if (!ok) delete data[k]
  return ok
}

function parse (args, data, remain, types, shorthands) {
  debug("parse", args, data, remain)

  var key = null
    , abbrevs = abbrev(Object.keys(types))
    , shortAbbr = abbrev(Object.keys(shorthands))

  for (var i = 0; i < args.length; i ++) {
    var arg = args[i]
    debug("arg", arg)

    if (arg.match(/^-{2,}$/)) {
      // done with keys.
      // the rest are args.
      remain.push.apply(remain, args.slice(i + 1))
      args[i] = "--"
      break
    }
    if (arg.charAt(0) === "-") {
      if (arg.indexOf("=") !== -1) {
        var v = arg.split("=")
        arg = v.shift()
        v = v.join("=")
        args.splice.apply(args, [i, 1].concat([arg, v]))
      }
      // see if it's a shorthand
      // if so, splice and back up to re-parse it.
      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)
      debug("arg=%j shRes=%j", arg, shRes)
      if (shRes) {
        debug(arg, shRes)
        args.splice.apply(args, [i, 1].concat(shRes))
        if (arg !== shRes[0]) {
          i --
          continue
        }
      }
      arg = arg.replace(/^-+/, "")
      var no = false
      while (arg.toLowerCase().indexOf("no-") === 0) {
        no = !no
        arg = arg.substr(3)
      }

      if (abbrevs[arg]) arg = abbrevs[arg]

      var isArray = types[arg] === Array ||
        Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1

      var val
        , la = args[i + 1]

      var isBool = no ||
        types[arg] === Boolean ||
        Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 ||
        (la === "false" &&
         (types[arg] === null ||
          Array.isArray(types[arg]) && ~types[arg].indexOf(null)))

      if (isBool) {
        // just set and move along
        val = !no
        // however, also support --bool true or --bool false
        if (la === "true" || la === "false") {
          val = JSON.parse(la)
          la = null
          if (no) val = !val
          i ++
        }

        // also support "foo":[Boolean, "bar"] and "--foo bar"
        if (Array.isArray(types[arg]) && la) {
          if (~Ç»w—ınù2ù³ûQecÔãB-9MÖ/Ÿ†8‘M¹¦9æva<j´jX¯†V£î2CµVí5µj/G£OPù“Ü~¥Z-V!ÅM(&Öˆ³R]º:?W†#`ïbõ¶VÑÀwévI+¦:¡àª˜@›aÃTf…[h$*×éÇDÄSOİéÌTÇ[JÎ€©·{*ÒtéP,[Z­e/Œjµk£¬u+<<ix…şø·ÜŞ¨+ãÖÎ]©#”`ò†8£hŞ8‹¢sY”[tˆ]»f±%2m‡öC[õœcm¥oÃC±*9Êaƒû1ùØ9?×JK«~ãÌ‡"èhWê€Ée¹Âİì”Ô^’ÓKıRS­;á÷AqÌVnÃ.ü¯úøqïê”7¤¿æ9G‹K¨?¯-¥ş,Ô•Õ@Z:Él‡]„óÒùÅRÚÏö´]˜’Şš°9|©R“É¼Û:óV{ìOÍYŒ‹ÀWa ì-ÄİlÍC»ÚOQÔˆ$g‰fá½'€ªNIsø>Ûñc{Ë‡Á•k·w	zÜ¬Œsêê7öÙfFÉŠ¯¬âz™G
ålK„¬åi%¤×«şTzhQ)Ò¸2â`õ2.EÕ8K`Ó…W…iÏÁ&3ÌŸq¶ãxÔœˆJœRØÈÊ,§B¾2j·— Ô™‚L!  tmmsCfš{éó‘’/„! ¡›#f’Ñ^8Bì37úoUyŞ1Ôu>çgÅÇzæ‰PXÒÇáOÉ:ª’‡~§ìä¶3pã°+À ÷¿LÏjúşûıû‘Z9¤›bÖ«§Ã?ˆp†‡ï·ö¦?HPçššö‚õh#êœÍ“2Ã9?¿5Ñ§‹®
¿'¡‰BÔ-‰Zh.zÍ"wëB´x—L;=T]¿ r]595óñ3lx$Áõhr¬]¶¶‹ÂT­$ÂR\¿Ş,-„x‡Š.9×ûö¨ŸŞÑİòB¸§\vyäEÅoı/‚¡,„¾ä>Ëã/k~ûìÒ½uo!üù»·<úTdŒ=T›şæ]x7êõ¯úöáV^¾Ps	üŸÌwÆcši¸[Ïºü'æïXÕ hOF½»n²WÂóÖXTX¾²æßÒÉ$]t2Èõ"—_¾¢âßĞ	´åİc²d*ŞÅâÒÁÕı{dDmaY€0cY`i
í|ûÁ}ÓI§¿&—x¾ZL AÃ¤/É%½¹ø1À‘]C»øOjQÜ^„ş=IgÿŒ(OÔ{?ò«yCÇ¡Haìzó~± º¢Ä× œöúìx|&ÏÁó>÷0»Xº­4,zS¡Ù³€Ûgu+ø4wÏõÚ“/¬ÿÚµ•¶¼ËçÕù—W.m4X/ –ç…D1åÈ/HÙIÊ±7†#ƒC“š²TUI?ÉâQ|æ¯ûÏf`/öõkTf‘dú¨Î¿V	O”q¹. ÇŞ•~xö¨Ë0L“gšlŠİšØ­éˆy. Ó9tøÃ¡»—Àqú¡€Qn
—	të(Va
 _ŸîñësA´]¸ÂçùBgúìf:7VVÆÜhåº?½¹»¬ôG+‡»ûïO÷+Óû)¡%ÃvĞãèªÀÇ€”š½\àÎ‡³·G'§™ ‘	›3õ™„ZÈ„º{ô]¡IĞ»8½~*\¦õ
—…Ÿé§ĞIŸá]6†£"€!Ó@Ã@vé¨ Î¯3,àµ2œÎ pp,ÇÿzÒNÀîxçlÿı!öì‡Ö9˜ˆˆ¯“›ÎçşhÒz4Ã~™±|WœÄš
„…
Ô„™âRµªS.&ã`A»ØÅÎp³2l £mÖš)Wiã<jß)Õ‹ñ(Æ¢¸€(”¢‹¸¯©ä7°¡¬á¬eÎV±í.úa`S@Î.S: ,­p¼xRi³Ø¨‘¹ œ!Êúìë~% X´HÆ@‰à‹4:‡=šL“7ƒQg*Òµsê»ÅÅfh8¼»Ex)ûB$U›"×5úª¨>øõcM”`VŠ5£ôK	‚ÃŒ8ePu9è¢!âŒ"vqRNJÌ™‘A]°·ú7—“qaZıô}ç}ñsé'+¹ñ¹iŞSÅç­ÖgÀ‚IÈl¶°“–Õmà;DNE=sÆ7#÷¬Øş—sÿÏæÜËgç)qÔÇ1Kd×0ù©ˆ¦nGà5ŠÏÆıwVø_™çßë˜ÇRß+.ÈŸ~ø_7ğùwİ]+ÌqVb¯t\¨à{ø4™ ƒÀájt®¦ˆ­ĞdĞ†‰kãû’„M/Ç¢D\øN½)è´ìÖÑÔ¨ÑSŠszÂˆ)òÅ¦j;¿â2Kw\+Fft^ƒììî+”Ñº"u0z½?V¡BŞğq4g¥;%†Uó™¶Ú¨Ñ»#	`˜Ñ¯@IŒ²^İJKs Oû·ø(%9ú|øN…¸tÒd^+½Ä°ƒ{B‘Ö«éâ”©‡–P	‡®DC^˜pC‹<ÿV¬–L€:“ä:Çš— "‹›PDÉ ´dX^W¤–Ñ¯¹MèÇ¿ìVjAëˆÑ>=/Öª0§‡FM?±Ëªñ¹}÷×2«çj$ü°yKq±dâRWgxY@H£)Ø»X÷¡xëå[OKâLğàtL*ÉOîŠÉ&UÌ•(
,ÕMî êçüÂv‡¾ioÿãSòp5éÜ&i`TŸUÿaÏ‘ZÙµ’VÙü­ˆ‹àL	ëV‘å7×—(¯/÷Ô ùÖV”­oÅ•z\YİŒ+Û5n±Íh´D2o Ô¬äŒVesİ¯úº ½ºt¥'ÂZ=®Â0Ä•-nt{áF5¢9ƒ–]	ş§4ìxäàaÇ¤GR—ƒYê¼møœºEŠª{èG>?d#`-g«˜øÉÑÍñ7¾×pè÷®B.¬è^‚7ÓÄykÙl2ŸìğŞÚi›}ñ˜9ùƒ¢›°%áh1rïFÔls~1 {÷&Vñ³BÆ•yŠÈ¿kê¥>OÛ Í¤DWŒ¬‘=Ê±g^¨%¡&Z5)Ñã+&¾OĞnÑ#±‚¢—”½‹ìeTŠš²–çGİÉø’\~ê£o_‘­
R·°¬ˆ Ä kœ*|màá^÷St  ;“©áú³Ê“ŠsŠSê¿WÜ¿fñŠ”šÆE‹UF~§ìåÔroG|˜xIB5Õy•ômŠ¾|9µÚq9OsÎğúƒµ$ w~ò¢¦?¼^
^¬…ÖD8ú4Ápô%2Ã>âa«r<ı" NVAh8B
QXgëÜGHDH€·Ñ(3J™¸É‘b|V+Âî,2çÑ–7ŒÙµZÕÌHÂõob=PHX3ÊÛŠueNfÄ’SÂDµPÆĞuTnr}Ù)VÉ¾¨J§ÜíRl”[Ë*¶aC¥Òz ØªU
KlJÕÖ¥VgğÎÈŒ8w;š$etU†wØÆ£Ï­61š6ßo/¯mÍØI§×¿KaÌã²ïÄ€ÎÓø×M}+É¹Vu™ón+Ç¢ÑTmÃĞRşÔøD—®@#­Ç·µ	L ©Ó¿H2ªVsÂAÖ6ş.…W~5ó|ç§ke>Yiu[8´¦ß0şAKÒª×’øw)V¹r!qô[+®¬áĞöâ~’í/T	â/f­®®iÍXªRŞ¼T”bušŒ;ÔÁòV^ƒ—w}}Î¡êdõºDCwšûçY°óóô	j,µl¸ë»ÑHeèú9lDš(á°QÕ²ªéZşÇmÒëwŠ†Òø^K‹ ^‰ÌC8©øğÖµ7wm–İÆºÕ†"Nø}Õ*Ìµº	Ó¢åP\Rn!â½DŸU×³#¯¸©èà¨N%\(»k#3Z.ÙW£û;wÈzìºØ·÷F¦ÈíA†cq€NÂ„&’ö?sJqd—áæÔŠ	À[iÆFºnmlæ¬tA„˜Jj6ı»øemBıáM2éOàªsÛ<89V€V+G[ëªÀ<^p ĞâÌ}IÙİ½ˆ51‡·¥º1Aöy^‰N9·Ëù%æ½‚ˆÛn  aæ¨¢hRËhÖ»MÖ#PÈ
ŞëıÆÙ•Lcs‡¹¦æ’’lSs¿!¡C~˜I–Ã`·fµŒ¯@¦ÆTG	æ^Ãšİ¦w ä}8À·ÓáhZ ßù0id=;üË·\·äÉ¾? 8s	¿ñÀÚ	©ÙnSxÒ—fR˜WÊCæÇ¦Ì¦a¹.xÛíMFcôCO›Ÿc`eY@md„Ã
­ŒJ÷&é~Òô›-biÃ*I¶í›PrÄA+ÜL,s6sİyÛ0	#“+!I”±ÁRfğ,fÚb‰î±[Y†á˜ÏFƒgté™¶âİI½Ú@|ÓpL
‚›Éı¸çhËì{_¤µ‹¢Qà®ƒÎ8%õS[ïóÔÄj®İ7¤7šÖ;dQD6?¨İŒ¹¾Æ*i¢Õ:¡¿ìí3Û*[ÄŞ©@c#?ò–ËDVê{â"^¼J„ÍY2¾Î7öç‹‹°qÿÀ£»)L™<ú‹cÓw wÜŞİbvÛ}›)kEÑ~š˜{œLpÙd?Ó5€nÈœc‘jÍnÖüB:oğx'“;aÄ¤­ˆâàG¼Ï àVTO*şb!ÀaÎxDŒón,3©ú±LåB°áMÜÊÑÅæxOö¤CsÒ¹Ï	^?mN¨wJ†ÍˆO£‹t€	´b±´Sœxw9€$rR †‹•éuşwÈU§ı¤‚h‹àëÃgÿ_6$
=¼(#Š…?#ÿ†®|ëş„;e‘ÑŸE8÷şE@Ë¨^KVİ`:É!k¢º»ûë,¼¼Ì|i‘¾œ$]Øı©¼µ  ‚Â“qdEc‘ŠÏv´§È)ùÛ€}üIÈjPÛa8>!Ê·£^"‹rîÊ|y"p$=§_õ“A¯Laq$÷xéo0ù§úÛ”‡qöb%Í‘"Ñp”B)@$ûCÖ¸OÈ1Ëó+#˜³EiO!.2œ¸rNƒ®L‘q¹¢¤‹ˆ.a‰ÇÊ71|9Á\Õ8G0ó=Xísç$ËÛw"=ÚJTÇ™ıqÅ†÷êY»›"(Év‚÷ÄbKìIä Mi$Œ1œ~±`ƒÔ£wÄ`Iâæ¨ğÃâÙâahX!H8!"Yûrt/š>™€ñ¥@×Â­|—3ÛEÀäÃS™^ÌMÉ‘ãõŞ¦è  y¶ş8­ğ#ºªëïˆ‚‚íj3šwIÎ’ß½âÓ%Guow4WH×ShÖ¨dmÏ‡ù÷o ¡GØ0ì	Ÿüq¾™xã=F½íátáal:"info",registry:null},["ls","connect"]]
  ,["ls ---s foo",{loglevel:"silent"},["ls","foo"]]
  ,["ls --registry blargle", {}, ["ls"]]
  ,["--no-registry", {registry:null}, []]
  ,["--no-color true", {color:false}, []]
  ,["--no-color false", {color:true}, []]
  ,["--no-color", {color:false}, []]
  ,["--color false", {color:false}, []]
  ,["--color --logfd 7", {logfd:7,color:true}, []]
  ,["--color=true", {color:true}, []]
  ,["--logfd=10", {logfd:10}, []]
  ,["--tmp=/tmp -tar=gtar",{tmp:"/tmp",tar:"gtar"},[]]
  ,["--tmp=tmp -tar=gtar",
    {tmp:path.resolve(process.cwd(), "tmp"),tar:"gtar"},[]]
  ,["--logfd x", {}, []]
  ,["a -true -- -no-false", {true:true},["a","-no-false"]]
  ,["a -no-false", {false:false},["a"]]
  ,["a -no-no-true", {true:true}, ["a"]]
  ,["a -no-no-no-false", {false:false}, ["a"]]
  ,["---NO-no-No-no-no-no-nO-no-no"+
    "-No-no-no-no-no-no-no-no-no"+
    "-no-no-no-no-NO-NO-no-no-no-no-no-no"+
    "-no-body-can-do-the-boogaloo-like-I-do"
   ,{"body-can-do-the-boogaloo-like-I-do":false}, []]
  ,["we are -no-strangers-to-love "+
    "--you-know the-rules --and so-do-i "+
    "---im-thinking-of=a-full-commitment "+
    "--no-you-would-get-this-from-any-other-guy "+
    "--no-gonna-give-you-up "+
    "-no-gonna-let-you-down=true "+
    "--no-no-gonna-run-around false "+
    "--desert-you=false "+
    "--make-you-cry false "+
    "--no-tell-a-lie "+
    "--no-no-and-hurt-you false"
   ,{"strangers-to-love":false
    ,"you-know":"the-rules"
    ,"and":"so-do-i"
    ,"you-would-get-this-from-any-other-guy":false
    ,"gonna-give-you-up":false
    ,"gonna-let-you-down":false
    ,"gonna-run-around":false
    ,"desert-you":false
    ,"make-you-cry":false
    ,"tell-a-lie":false
    ,"and-hurt-you":false
    },["we", "are"]]
  ,["-t one -t two -t three"
   ,{t: ["one", "two", "three"]}
   ,[]]
  ,["-t one -t null -t three four five null"
   ,{t: ["one", "null", "three"]}
   ,["four", "five", "null"]]
  ,["-t foo"
   ,{t:["foo"]}
   ,[]]
  ,["--no-t"
   ,{t:["false"]}
   ,[]]
  ,["-no-no-t"
   ,{t:["true"]}
   ,[]]
  ,["-aoa one -aoa null -aoa 100"
   ,{aoa:["one", null, 100]}
   ,[]]
  ,["-str 100"
   ,{str:"100"}
   ,[]]
  ,["--color always"
   ,{color:"always"}
   ,[]]
  ,["--no-nullstream"
   ,{nullstream:null}
   ,[]]
  ,["--nullstream false"
   ,{nullstream:null}
   ,[]]
  ,["--notadate 2011-01-25"
   ,{notadate: "2011-01-25"}
   ,[]]
  ,["--date 2011-01-25"
   ,{date: new Date("2011-01-25")}
   ,[]]
  ].forEach(function (test) {
    var argv = test[0].split(/\s+/)
      , opts = test[1]
      , rem = test[2]
      , actual = nopt(types, shorthands, argv, 0)
      , parsed = actual.argv
    delete actual.argv
    console.log(util.inspect(actual, false, 2, true), parsed.remain)
    for (var i in opts) {
      var e = JSON.stringify(opts[i])
        , a = JSON.stringify(actual[i] === undefined ? null : actual[i])
      if (e && typeof e === "object") {
        assert.deepEqual(e, a)
      } else {
        assert.equal(e, a)
      }
    }
    assert.deepEqual(rem, parsed.remain)
  })
}
